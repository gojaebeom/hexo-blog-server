---
title: JAVA - 17. 상속 04
thumbnail: https://user-images.githubusercontent.com/62233873/78540149-aa58da80-782e-11ea-9754-33ae5e40ec43.jpg
date: 2020-04-27 21:09:00
tags: 
- java
- 상속
- Object
category:
- 웹 개발
- java

#카탈로그 생성 및 위치
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
  - type: tagcloud
    position: right
#위치고정 여부
sidebar:
  right:
    sticky: true
---

## Object 클래스
클래스를 정의할 때 어떤 클래스도 상속하지 않으면 해당 클래스는 java.lang 패키지에 묶여 있는 Object 클래스를 상속하게 된다.
<!-- more -->
```java
class MyClass {...}

class MyClass extends Object {...}
```
두 클래스의 정의는 동일하다.

물론 위의 설명에도 언급했듯이 상속하는 클래스가 있는 경우에는 Object 클래스를 상속하지 않는다.
```java
class MyClass extends OtherClass {...} 
```

그러나 이 경우에도 OtherClass 또는 OtherClass가 상속하는 클래스가 Object 클래스를 상속한다. 결국 자바의 모든 클래스는 Object 클래스를 직접 혹은 간접적으로 상속하게 되어있다. 그렇다면 자바의 모든 클래스는 Object 클래스를 상속하도록 한 이유는 무엇일까?

이는 자바의 모든 인스턴스에 공통된 기준 및 규약을 적용하기 위함이다. 한 예로 자바의 모든 인스턴스는 다음 메소드의 인자로 전달될 수 있다.

```java
public void println(Object x) // System.out.println 메소드
```
위 메소드의 매개변수 형이 Object이다. 따라서 자바의 모든 인스턴스는 위 메소드의 인자가 될 수 있다. 그리고 위의 메소드는 인자로 전달된 인스턴스의 다음 메소드를 호출한다. 이 메소드는 Object 클래스에 정의되어 있는 메소드이므로 모든 인스턴스를 대상으로 호출이 가능하다.

이 블로그엔 포스팅하지 않았지만 글쓴이의 github 에 [String 클래스 예제](https://github.com/gojaebeom/java_tutorial)에 대해 다루었다.(목차에서 String 클래스 부분의 글들을 찾아보면 된다) 

이 예제에서 클래스를 정의하면서 toString 메소드를 정의한 바 있다. 그런데 사실 이것은 Object 클래스의 toString 메소드를 오버라이딩 한 것 이다. 이와 관련해서 다음 예제를 살펴보자.

```java
class Bread{
	
	//오브젝트 클래스의 toString 메소드를 오버라이딩
	public String toString() {
		System.out.println(super.toString());
		return "My Bread";
	}
}

class CreamBread extends Bread{
	
	//Bread 클래스의 toString 메소드를 오버라이딩
	public String toString() {
		
		return "my CreamBread";
	}
}

public class OverridingToString {
	public static void main(String[] args) {
		Bread b1 = new Bread();
		Bread b2 = new CreamBread();
		
		//b1이 참조하는 인스턴스의 toString 메소드 호출로 이어짐
		System.out.println(b1);
		
		//b2가 참조하는 인스턴스의 toString 메소드 호출로 이어짐
		System.out.println(b2);
	}
}
```

## 클래스와 메소드의 final 선언
클래스를 정의하는데 있어서 해당 클래스를 다른 클래스가 상속하는 것을 원치 않는다면, 다음과 같이 final 선언을 추가하면 된다.
```java
public final class MyClass{...} //MyClass 는 다른 클래스가 상속 할 수 없음
```

대표적인 final 클래스로 String 클래스가 있다. 따라서 우리는 String 클래스를 상속할 수 없다. 또한 다음과 같이 메소드의 정의에 final 선언을 추가하여 해당 메소드의 오버라이딩을 허용하지 않을 수 도 있다.

```java
public final void func(){...}
```

## @Override
자바 5에서 '어노테이션(Annotations)'이라는 것이 소개되었다. 그리고 이와 관련하여 이후에 별도로 설명을 하겠다. 그러나 상속, 정확히는 메소드 오버라이딩과 관련 있는 내용이 있어 이에 대한 부분만 먼저 소개하고자 한다. 다음 예제를 보자. 이 예제는 컴파일도 되고 실행도 잘 된다. 그러나 프로그래머의 실수가 일부 포함되어 있다. 그 실수가 무엇인지찾아보자.

```java
class ParentAdder{
	public int add(int a, int b) {
		
		return a + b;
	}
}

class ChildAdder extends ParentAdder{
	
	// 상위 클래스의 add를 오버라이딩 하려고 합니다.
	public double add(double a, double b) {
		return a + b;
	}
}

public class OverrideMistake {
	public static void main(String[] args) {
		ParentAdder adder = new ChildAdder();
		System.out.println(adder.add(3, 4));
	}
}
```

클래스 ChildAdder 는 ParentAdder를 상속한다. 그리고 ParentAdder의 add를 오버라이딩 할 의도였음을 주석을 통해 알 수 있다. 그러나 부모 메소드와 매개변수 타입과 반환형이 달랐기 때문이다. 이러한 유형의 실수는 매우 흔하다. 그럼에도 불구하고 발견이 쉽지 않기 때문에 치명적인 실수가 될 수 있다. 제일 좋은 것은 컴파일 과정에서 실수가 확인되는 것이다. 그러나 이 경우 문법적으로는 오류가 없기 때문에 컴파일도 되고 실행도 된다.

이러한 상황을 방지하기 위해서 '어노테이션' 이라는 것을 사용할 수 있다. 어노테이션은 일종의 메모이다. 그것도 '자바 컴파일러에게 메시지를 전달하는 목적의 메모'이다. ChildAdder 클래스를 설계하는 과정에서 add 메소드가 ParentAdder의 add 메소드를 오버라이딩 할 의도였다면 다음과 같이 메모를 달아준다.

```java 
class ChildAdder extends ParentAdder{
	
	// 상위 클래스의 add를 오버라이딩 하려고 합니다.
    @Override
	public double add(double a, double b) {
		return a + b;
	}
}
```

위와같이 어노테이션을 정의하면 컴파일러는 오버라이딩이 제대로 되었는지 확인을 하고, 프로그래머의 의도대로 오버라이딩이 되지 않았다면 컴파일 단계에서 에러를 전달해준다.

메소드를 오버라이딩 해야 한다면, 이렇듯 어노테이션을 사용하여 컴파일 과정에서 확인되지 않는 오류의 발생을 차단하는 것이 좋다.

> 본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.
