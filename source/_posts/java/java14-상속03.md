---
title: JAVA - 14. 상속03
thumbnail: https://user-images.githubusercontent.com/62233873/78540149-aa58da80-782e-11ea-9754-33ae5e40ec43.jpg
date: 2020-04-27 20:01:00
tags: 
- java
- 상속
- 메소드 오버라이딩
- method overriding
category:
- 웹 개발
- java

#카탈로그 생성 및 위치
toc: true
widgets:
  - type: toc
    position: right
  - type: category
    position: right
  - type: tagcloud
    position: right
#위치고정 여부
sidebar:
  right:
    sticky: true
---

## 메소드 오버라이딩(Method Overriding)이란?
상위 클래스에 정의된 메소드를 하위 클래스에서 다시 정의하는 행위를 가리켜 '메소드 오버라이딩' 이라 하는데, 여기서 말하는 오버라이딩은 '무효화 시키다'의 뜻으로 해석이 된다. <!-- more -->

다음 예제를 통해 메소드 오버라이딩의 결과를 확인해보자.
```java
class Cake{
	public void yummy() {
		System.out.println("Yummy Cake");
	}
}

class CheeseCake extends Cake{
	public void yummy() {// Cake의 Yummy 메소드를 오버라이딩 함
		System.out.println("Yummy Cheese Cake");
	}
}

public class YummyCakeOverriding {
	public static void main(String[] args) {
		Cake c1 = new CheeseCake();
		CheeseCake c2 = new CheeseCake();
		
		c1.yummy(); //오버라이딩 한 CheeseCake의 Yummy 메소드가 호출됨
		c2.yummy(); //오버라이딩 한 CheeseCake의 Yummy 메소드가 호출됨
	}
}
```
  실행 결과 : Yummy Cheese Cake가 두번 출력 되는 것을 알 수 있다.

위의 CheeseCake 클래스는 Cake를 상속하면서, Cake에 정의된 yummy메소드와 다음 세 가지가 같은 메소드를 정의하였다.
- 메소드의 이름
- 메소드의 반환형
- 메소드의 매개변수 선언

위의 세가지가 같아야 메소드 오버라이딩이 성립한다.

즉 Cake의 yummy 메소드를 CheeseCake의 Yummy 메소드가 오버라이딩 하였다. 그리고 오버라이딩을 하면, 참조변수의 형에 상관없이 오버라이딩 한 메소드가 오버라이딩된 메소드를 대신하게 된다. 

위의 예제의 main 메소드에서 다음과 같이 Cake 형 참조변수로 CheeseCake 인스턴스를 참조하였다.
```java
Cake c1 = new CheeseCake();
```

그리고 다음과 같이 yummy 메소드를 호출하였다.
```java
c1.yummy();
```

앞서 설명한 바에 의하면 c1은 Cake형 참조변수이니, 위 문장의 경우 Cake의 yummy 메소드가 호출되어야 한다. CheeseCake 인스턴스를 참조하고 있는 상황이라도 말이다. 그러나 Cake의 yummy 메소드는 오버라이딩 되었다(무효화 되었다). 따라서 이 경우에는 CheeseCake의 yummy 메소드가 대신 호출이 된다.

## 메소드 오버라이딩의 일반화
앞서 설명한 메소드 오버라이딩을 문법적으로 정리하기 위해서 클래스를 다음과 같이 정의하였다.
```java
class Cake{
  public void yummy(){...}
}
class CheeseCake extends Cake{
  public void yummy(){...}
}
class StrawberryCheeseCake extends CheeseCake{
  public void yummy(){...}
}
```

위와 같이 클래스를 정의한 경우 CheeseCake의 참조변수와 인스턴스의 생성문을 다음과 같이 구성할 수 있다.
```java
Cake c1 = new StrawberryCheeseCake();
CheeseCake c2 = new StrawberryCheeseCake();
StrawberryCheeseCake c3 = new StrawberryCheeseCake();
```

그리고 다음 세 문장이 실행되었을 때 호출되는 메소드는 StrawberryCheeseCake의 yummy 메소드이다.
```java
c1.yummy(); //StrawberryCheeseCake의 yummy 메소드 호출
c2.yummy(); //StrawberryCheeseCake의 yummy 메소드 호출
c3.yummy(); //StrawberryCheeseCake의 yummy 메소드 호출
```

## 오버라이딩된 메소드를 호출하는 방법
위의 예제들에서도 알 수 있듯이 Cake, CheeseCake에 정의된 yummy 메소드들을 위의 방법처럼 호출하는 것은 불가능하다.

하지만 클래스 외부가 아닌 내부에서 Cake의 yummy 메소드를 호출하는 방법은 있다. 다음 예제를 살펴보자.

```java
package ch11_상속;
//오버라이딩 된 메소드를 호출하는 방법 예제

class Cake{
	public void yummy() {
		System.out.println("Yummy Cake");
	}
}

class CheeseCake extends Cake{
	public void yummy() {
		super.yummy();
		System.out.println("Yummy CheeseCake");
	}
}

public class YummyCakeSuper {
	public static void main(String[] args) {
		CheeseCake cake = new CheeseCake();
		cake.yummy();
	}
}
```
지금까지는 상위 클래스의 생성자를 호출할 목적으로 키워드 super를 사용하였다. 그런데 위의 예제에서 보이듯이 상위 클래스에 정의된, 오버라이딩 된 메소드의 호출을 목적으로도 super가 사용될 수 있다.

> 본 문서는 책의 일부 내용을 발췌한 것으로서 온오프라인 상의 무단 배포를 금합니다.